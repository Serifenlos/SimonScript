const{PI:PI,sin:sin,cos:cos,acos:acos,atan2:atan2,sqrt:sqrt,random:random,abs:abs}=Math;class Vec2{#t;#s;constructor(t=0,s=0){this.#t=t,this.#s=s}static add(t,s){return new Vec2(t.#t+s.#t,t.#s+s.#s)}static angleBetween(t,s){return atan2(t.#t*s.#s-t.#s*s.#t,t.#t*s.#t+t.#s*s.#s)}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),h=abs(t.#s-s.#s);return i>=h?i:h}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)}static distanceMinkowski(t,s,i){return(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s}static fromPolarCoords(t,s){return new Vec2(t*cos(s),t*sin(s))}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)}static isZero(t){return 0===t.#t&&0===t.#s}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec2(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i)}static negate(t){return new Vec2(-t.#t,-t.#s)}static normalize(t){const s=t.magnitude;return new Vec2(t.#t/s,t.#s/s)}static project(t,s){const i=s.magnitude,h=t.magnitude*cos(atan2(t.#t*s.#s-t.#s*s.#t,t.#t*s.#t+t.#s*s.#s));return new Vec2(s.#t/i*h,s.#s/i*h)}static random(){const t=random()*PI*2;return new Vec2(cos(t),sin(t))}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s}static scale(t,s){return new Vec2(t.#t*s,t.#s*s)}static subtract(t,s){return new Vec2(t.#t-s.#t,t.#s-s.#s)}get angleX(){return atan2(this.#s,this.#t)+(this.#s<0?2*PI:0)}get angleY(){return-atan2(this.#t,this.#s)+(this.#t>0?2*PI:0)}get magnitude(){return sqrt(this.#t**2+this.#s**2)}get magnitudeSq(){return this.#t**2+this.#s**2}get x(){return this.#t}get xy(){return[this.#t,this.#s]}get y(){return this.#s}set angleX(t){const s=this.magnitude;this.#t=s*cos(t),this.#s=s*sin(t)}set angleY(t){const s=this.magnitude;this.#t=s*-sin(t),this.#s=s*cos(t)}set magnitude(t){const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t}set x(t){this.#t=t}set xy(t){this.x=t[0],this.y=t[1]}set y(t){this.#s=t}add(t){return this.#t+=t.#t,this.#s+=t.#s,this}angleBetween(t){return atan2(this.#t*t.#s-this.#s*t.#t,this.#t*t.#t+this.#s*t.#s)}clamp(t,s){const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t),this}clone(){return new Vec2(this.#t,this.#s)}copy(t){return this.#t=t.#t,this.#s=t.#s,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2}dot(t){return this.#t*t.#t+this.#s*t.#s}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)}isZero(){return 0===this.#t&&0===this.#s}limitMax(t){const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this}project(t){const s=t.magnitude,i=this.magnitude*cos(atan2(this.#t*t.#s-this.#s*t.#t,this.#t*t.#t+this.#s*t.#s));return this.#t=t.#t/s*i,this.#s=t.#s/s*i,this}random(){const t=random()*PI*2,s=this.magnitude;return this.#t=s*cos(t),this.#s=s*sin(t),this}rotateZ(t){const s=cos(t),i=sin(t),h=this.#t;return this.#t=this.#t*s-this.#s*i,this.#s=h*i+this.#s*s,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s}scale(t){return this.#t*=t,this.#s*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this}turnLeft(){const t=this.#t;return this.#t=-this.#s,this.#s=t,this}turnRight(){const t=this.#t;return this.#t=this.#s,this.#s=-t,this}zero(){return this.#t=0,this.#s=0,this}*[Symbol.iterator](){yield this.#t,yield this.#s}}class Vec3{#t;#s;#i;constructor(t=0,s=0,i=0){this.#t=t,this.#s=s,this.#i=i}static add(t,s){return new Vec3(t.#t+s.#t,t.#s+s.#s,t.#i+s.#i)}static angleBetween(t,s){return acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i)/(t.magnitude*s.magnitude))}static cross(t,s){return new Vec3(t.#s*s.#i-t.#i*s.#s,t.#i*s.#t-t.#t*s.#i,t.#t*s.#s-t.#s*s.#t)}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),h=abs(t.#s-s.#s),e=abs(t.#i-s.#i);return i>=h&&i>=e?i:h>=e?h:e}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)+abs(t.#i-s.#i)}static distanceMinkowski(t,s,i){return(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i+abs(t.#i-s.#i)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s+t.#i*s.#i}static fromCylindricalCoords(t,s,i){return new Vec3(t*cos(s),t*sin(s),i)}static fromSphericalCoords(t,s,i){return new Vec3(t*sin(s)*cos(i),t*sin(s)*sin(i),t*cos(s))}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0||t.#i===1/0||t.#i===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)||isNaN(t.#i)}static isZero(t){return 0===t.#t&&0===t.#s&&0===t.#i}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec3(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i,t.#i+(s.#i-t.#i)*i)}static negate(t){return new Vec3(-t.#t,-t.#s,-t.#i)}static normalize(t){const s=t.magnitude;return new Vec3(t.#t/s,t.#s/s,t.#i/s)}static project(t,s){const i=t.magnitude,h=s.magnitude,e=i*cos(acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i)/(i*h)));return new Vec3(s.#t/h*e,s.#s/h*e,s.#i/h*e)}static random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2);return new Vec3(2*t*i,2*s*i,1-2*(t**2+s**2))}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s&&t.#i===s.#i}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s&&t.#i===-s.#i}static scale(t,s){return new Vec3(t.#t*s,t.#s*s,t.#i*s)}static subtract(t,s){return new Vec3(t.#t-s.#t,t.#s-s.#s,t.#i-s.#i)}get angleX(){return atan2(sqrt(this.#s**2+this.#i**2),this.#t)}get angleY(){return atan2(sqrt(this.#i**2+this.#t**2),this.#s)}get angleZ(){return atan2(sqrt(this.#t**2+this.#s**2),this.#i)}get b(){return this.#i}get g(){return this.#s}get magnitude(){return sqrt(this.#t**2+this.#s**2+this.#i**2)}get magnitudeSq(){return this.#t**2+this.#s**2+this.#i**2}get r(){return this.#t}get rgb(){return[this.#t,this.#s,this.#i]}get x(){return this.#t}get xyz(){return[this.#t,this.#s,this.#i]}get y(){return this.#s}get z(){return this.#i}set b(t){this.#i=t}set g(t){this.#s=t}set magnitude(t){const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t}set r(t){this.#t=t}set rgb(t){this.x=t[0],this.y=t[1],this.z=t[2]}set x(t){this.#t=t}set xyz(t){this.x=t[0],this.y=t[1],this.z=t[2]}set y(t){this.#s=t}set z(t){this.#i=t}add(t){return this.#t+=t.#t,this.#s+=t.#s,this.#i+=t.#i,this}angleBetween(t){return acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i)/(this.magnitude*t.magnitude))}clamp(t,s){const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s,this.#i=this.#i/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t,this.#i=this.#i/i*t),this}clone(){return new Vec3(this.#t,this.#s,this.#i)}copy(t){return this.#t=t.#t,this.#s=t.#s,this.#i=t.#i,this}cross(t){const s=this.#t,i=this.#s;return this.#t=this.#s*t.#i-this.#i*t.#s,this.#s=this.#i*t.#t-s*t.#i,this.#i=s*t.#s-i*t.#t,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2}dot(t){return this.#t*t.#t+this.#s*t.#s+this.#i*t.#i}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0||this.#i===1/0||this.#i===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)||isNaN(this.#i)}isZero(){return 0===this.#t&&0===this.#s&&0===this.#i}limitMax(t){const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this.#i=t.#i/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this.#i*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this.#i/=t,this}project(t){const s=this.magnitude,i=t.magnitude,h=s*cos(acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i)/(s*i)));return this.#t=t.#t/i*h,this.#s=t.#s/i*h,this.#i=t.#i/i*h,this}random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2),h=this.magnitude;return this.#t=2*h*t*i,this.#s=2*h*s*i,this.#i=h*(1-2*(t**2+s**2)),this}rotateX(t){const s=cos(t),i=sin(t),h=this.#s;return this.#s=this.#s*s-this.#i*i,this.#i=h*i+this.#i*s,this}rotateY(t){const s=cos(t),i=sin(t),h=this.#t;return this.#t=this.#t*s+this.#i*i,this.#i=h*i+this.#i*s,this}rotateZ(t){const s=cos(t),i=sin(t),h=this.#t;return this.#t=this.#t*s-this.#s*i,this.#s=h*i+this.#s*s,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s&&this.#i===t.#i}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s&&this.#i===-t.#i}scale(t){return this.#t*=t,this.#s*=t,this.#i*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this.#i-=t.#i,this}zero(){return this.#t=0,this.#s=0,this.#i=0,this}*[Symbol.iterator](){yield this.#t,yield this.#s,yield this.#i}}class Vec4{#t;#s;#i;#h;constructor(t=0,s=0,i=0,h=0){this.#t=t,this.#s=s,this.#i=i,this.#h=h}static add(t,s){return new Vec4(t.#t+s.#t,t.#s+s.#s,t.#i+s.#i,t.#h+s.#h)}static angleBetween(t,s){return acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#h*s.#h)/(t.magnitude*s.magnitude))}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2+(t.#h-s.#h)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),h=abs(t.#s-s.#s),e=abs(t.#i-s.#i),r=abs(t.#h-s.#h);return i>=h&&i>=e&&i>=r?i:h>=e&&h>=r?h:e>=r?e:r}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)+abs(t.#i-s.#i)+abs(t.#h-s.#h)}static distanceMinkowski(t,s,i){return(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i+abs(t.#i-s.#i)**i+abs(t.#h-s.#h)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2+(t.#h-s.#h)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#h*s.#h}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0||t.#i===1/0||t.#i===-1/0||t.#h===1/0||t.#h===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)||isNaN(t.#i)||isNaN(t.#h)}static isZero(t){return 0===t.#t&&0===t.#s&&0===t.#i&&0===t.#h}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec4(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i,t.#i+(s.#i-t.#i)*i,t.#h+(s.#h-t.#h)*i)}static negate(t){return new Vec4(-t.#t,-t.#s,-t.#i,-t.#h)}static normalize(t){const s=t.magnitude;return new Vec4(t.#t/s,t.#s/s,t.#i/s,t.#h/s)}static project(t,s){const i=t.magnitude,h=s.magnitude,e=i*cos(acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#h*s.#h)/(i*h)));return new Vec4(s.#t/h*e,s.#s/h*e,s.#i/h*e,s.#h/h*e)}static random(){let t,s,i,h;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,h=2*random()-1}while(t**2+s**2>=1||i**2+h**2>=1);const e=sqrt((1-t**2-s**2)/(i**2+h**2));return new Vec4(t,s,i*e,h*e)}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s&&t.#i===s.#i&&t.#h===s.#h}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s&&t.#i===-s.#i&&t.#h===-s.#h}static scale(t,s){return new Vec4(t.#t*s,t.#s*s,t.#i*s,t.#h*s)}static subtract(t,s){return new Vec4(t.#t-s.#t,t.#s-s.#s,t.#i-s.#i,t.#h-s.#h)}get a(){return this.#h}get angleW(){return atan2(sqrt(this.#t**2+this.#s**2+this.#i**2),this.#h)}get angleX(){return atan2(sqrt(this.#s**2+this.#i**2+this.#h**2),this.#t)}get angleY(){return atan2(sqrt(this.#i**2+this.#h**2+this.#t**2),this.#s)}get angleZ(){return atan2(sqrt(this.#h**2+this.#t**2+this.#s**2),this.#i)}get b(){return this.#i}get g(){return this.#s}get magnitude(){return sqrt(this.#t**2+this.#s**2+this.#i**2+this.#h**2)}get magnitudeSq(){return this.#t**2+this.#s**2+this.#i**2+this.#h**2}get r(){return this.#t}get rgba(){return[this.#t,this.#s,this.#i,this.#h]}get w(){return this.#h}get x(){return this.#t}get xyzw(){return[this.#t,this.#s,this.#i,this.#h]}get y(){return this.#s}get z(){return this.#i}set a(t){this.#h=t}set b(t){this.#i=t}set g(t){this.#s=t}set magnitude(t){const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#h=this.#h/s*t}set r(t){this.#t=t}set rgba(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}set w(t){this.#h=t}set x(t){this.#t=t}set xyzw(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}set y(t){this.#s=t}set z(t){this.#i=t}add(t){return this.#t+=t.#t,this.#s+=t.#s,this.#i+=t.#i,this.#h+=t.#h,this}angleBetween(t){return acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#h*t.#h)/(this.magnitude*t.magnitude))}clamp(t,s){const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s,this.#i=this.#i/i*s,this.#h=this.#h/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t,this.#i=this.#i/i*t,this.#h=this.#h/i*t),this}clone(){return new Vec4(this.#t,this.#s,this.#i,this.#h)}copy(t){return this.#t=t.#t,this.#s=t.#s,this.#i=t.#i,this.#h=t.#h,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2+(this.#h-t.#h)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2+(this.#h-t.#h)**2}dot(t){return this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#h*t.#h}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0||this.#i===1/0||this.#i===-1/0||this.#h===1/0||this.#h===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)||isNaN(this.#i)||isNaN(this.#h)}isZero(){return 0===this.#t&&0===this.#s&&0===this.#i&&0===this.#h}limitMax(t){const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#h=this.#h/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#h=this.#h/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this.#i=t.#i/i*s,this.#h=t.#h/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this.#i*=-1,this.#h*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this.#i/=t,this.#h/=t,this}project(t){const s=this.magnitude,i=t.magnitude,h=s*cos(acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#h*t.#h)/(s*i)));return this.#t=t.#t/i*h,this.#s=t.#s/i*h,this.#i=t.#i/i*h,this.#h=t.#h/i*h,this}random(){let t,s,i,h;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,h=2*random()-1}while(t**2+s**2>=1||i**2+h**2>=1);const e=sqrt((1-t**2-s**2)/(i**2+h**2)),r=this.magnitude;return this.#t=r*t,this.#s=r*s,this.#i=r*i*e,this.#h=r*h*e,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s&&this.#i===t.#i&&this.#h===t.#h}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s&&this.#i===-t.#i&&this.#h===-t.#h}scale(t){return this.#t*=t,this.#s*=t,this.#i*=t,this.#h*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this.#i-=t.#i,this.#h-=t.#h,this}zero(){return this.#t=0,this.#s=0,this.#i=0,this.#h=0,this}*[Symbol.iterator](){yield this.#t,yield this.#s,yield this.#i,yield this.#h}}export{Vec2,Vec3,Vec4};