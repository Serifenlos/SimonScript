var{PI:X,sin:y,cos:g,acos:m,atan2:c,sqrt:o,random:f,abs:a}=Math,b=X*2;class d{#i=0;#n=new Float64Array([0,0]);#t=new Float64Array(2);#s(t=this.#t[0],s=this.#t[1]){if(t!==this.#n[0]||s!==this.#n[1])this.#i=o(t**2+s**2),this.#n[0]=t,this.#n[1]=s}constructor(t=0,s=0){this.#t[0]=t,this.#t[1]=s,this.#s(t,s)}static add(t,s){return new d(t.#t[0]+s.#t[0],t.#t[1]+s.#t[1])}static angleBetween(t,s){const i=t.#t[0],n=t.#t[1],h=s.#t[0],e=s.#t[1];return c(i*e-n*h,i*h+n*e)}static distance(t,s){return o((t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2)}static distanceChebyshev(t,s){const i=a(t.#t[0]-s.#t[0]),n=a(t.#t[1]-s.#t[1]);return i>=n?i:n}static distanceManhattan(t,s){return a(t.#t[0]-s.#t[0])+a(t.#t[1]-s.#t[1])}static distanceMinkowski(t,s,i){return(a(t.#t[0]-s.#t[0])**i+a(t.#t[1]-s.#t[1])**i)**(1/i)}static distanceSq(t,s){return(t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2}static dot(t,s){return t.#t[0]*s.#t[0]+t.#t[1]*s.#t[1]}static fromPolarCoords(t,s){return new d(t*g(s),t*y(s))}static immutable(t=0,s=0){const i=new Float64Array(10);i[0]=t,i[1]=s,i[4]=c(s,t)+(s<0?b:0),i[5]=-c(t,s)+(t>0?b:0);const n=t**2+s**2;i[8]=o(n),i[9]=n;const h=t===1/0||t===-1/0||s===1/0||s===-1/0,e=isNaN(t)&&isNaN(s),r=t===0&&s===0,u=Object.freeze([...i.slice(0,2)]);return{get angleX(){return i[4]},get angleY(){return i[5]},get isInfinite(){return h},get isNaN(){return e},get isZero(){return r},get magnitude(){return i[8]},get magnitudeSq(){return i[10]},get x(){return i[0]},get xy(){return u},get y(){return i[1]}}}static isInfinite(t){const s=t.#t[0],i=t.#t[1];return s===1/0||s===-1/0||i===1/0||i===-1/0}static isNaN(t){return isNaN(t.#t[0])||isNaN(t.#t[1])}static isZero(t){return t.#t[0]===0&&t.#t[1]===0}static lerp(t,s,i){if(i>1)i=1;else if(i<0)i=0;const n=t.#t[0],h=t.#t[1];return new d(n+(s.#t[0]-n)*i,h+(s.#t[1]-h)*i)}static negate(t){return new d(-t.#t[0],-t.#t[1])}static normalize(t){const s=t.#i;return new d(t.#t[0]/s,t.#t[1]/s)}static project(t,s){const i=t.#t[0],n=t.#t[1],h=s.#t[0],e=s.#t[1],r=s.#i,u=t.#i*g(c(i*e-n*h,i*h+n*e));return new d(h/r*u,e/r*u)}static random(){const t=f()*b;return new d(g(t),y(t))}static satisfyEquality(t,s){return t.#t[0]===s.#t[0]&&t.#t[1]===s.#t[1]}static satisfyOpposition(t,s){return t.#t[0]===-s.#t[0]&&t.#t[1]===-s.#t[1]}static scale(t,s){return new d(t.#t[0]*s,t.#t[1]*s)}static subtract(t,s){return new d(t.#t[0]-s.#t[0],t.#t[1]-s.#t[1])}static zero(){return new d}get angleX(){return c(this.#t[1],this.#t[0])+(this.#t[1]<0?b:0)}get angleY(){return-c(this.#t[0],this.#t[1])+(this.#t[0]>0?b:0)}get magnitude(){return this.#i}get magnitudeSq(){return this.#i**2}get x(){return this.#t[0]}get xy(){return[...this.#t]}get y(){return this.#t[1]}set angleX(t){const s=this.#i;this.#t[0]=s*g(t),this.#t[1]=s*y(t),this.#s()}set angleY(t){const s=this.#i;this.#t[0]=s*-y(t),this.#t[1]=s*g(t),this.#s()}set magnitude(t){const s=this.#i;this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#s()}set x(t){this.#t[0]=t,this.#s()}set xy(t){this.#t[0]=t[0],this.#t[1]=t[1],this.#s()}set y(t){this.#t[1]=t,this.#s()}add(t){return this.#t[0]+=t.#t[0],this.#t[1]+=t.#t[1],this.#s(),this}angleBetween(t){const s=this.#t[0],i=this.#t[1],n=t.#t[0],h=t.#t[1];return c(s*h-i*n,s*n+i*h)}clamp(t,s){const i=this.#i;if(i>s)this.#t[0]=this.#t[0]/i*s,this.#t[1]=this.#t[1]/i*s,this.#s();else if(i<t)this.#t[0]=this.#t[0]/i*t,this.#t[1]=this.#t[1]/i*t,this.#s();return this}clone(){return new d(this.#t[0],this.#t[1])}copy(t){return this.#t[0]=t.#t[0],this.#t[1]=t.#t[1],this.#s(),this}distance(t){return o((this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2)}distanceSq(t){return(this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2}dot(t){return this.#t[0]*t.#t[0]+this.#t[1]*t.#t[1]}isInfinite(){const t=this.#t[0],s=this.#t[1];return t===1/0||t===-1/0||s===1/0||s===-1/0}isNaN(){return isNaN(this.#t[0])||isNaN(this.#t[1])}isZero(){return this.#t[0]===0&&this.#t[1]===0}limitMax(t){const s=this.#i;if(s>t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#s();return this}limitMin(t){const s=this.#i;if(s<t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#s();return this}lookAt(t){const s=this.#i,i=t.#i;return this.#t[0]=t.#t[0]/i*s,this.#t[1]=t.#t[1]/i*s,this.#s(),this}negate(){return this.#t[0]*=-1,this.#t[1]*=-1,this.#s(),this}normalize(){const t=this.#i;return this.#t[0]/=t,this.#t[1]/=t,this.#s(),this}project(t){const s=this.#t[0],i=this.#t[1],n=t.#t[0],h=t.#t[1],e=t.#i,r=this.#i*g(c(s*h-i*n,s*n+i*h));return this.#t[0]=n/e*r,this.#t[1]=h/e*r,this.#s(),this}random(){const t=f()*b,s=this.#i;return this.#t[0]=s*g(t),this.#t[1]=s*y(t),this.#s(),this}rotateZ(t){const s=g(t),i=y(t),n=this.#t[0],h=this.#t[1];return this.#t[0]=n*s-h*i,this.#t[1]=n*i+h*s,this.#s(),this}satisfyEquality(t){return this.#t[0]===t.#t[0]&&this.#t[1]===t.#t[1]}satisfyOpposition(t){return this.#t[0]===-t.#t[0]&&this.#t[1]===-t.#t[1]}scale(t){return this.#t[0]*=t,this.#t[1]*=t,this}subtract(t){return this.#t[0]-=t.#t[0],this.#t[1]-=t.#t[1],this.#s(),this}turnLeft(){const t=this.#t[0];return this.#t[0]=-this.#t[1],this.#t[1]=t,this.#s(),this}turnRight(){const t=this.#t[0];return this.#t[0]=this.#t[1],this.#t[1]=-t,this.#s(),this}zero(){return this.#t[0]=0,this.#t[1]=0,this.#s(),this}*[Symbol.iterator](){yield this.#t[0],yield this.#t[1]}}class l{#i=0;#n=new Float64Array([0,0,0]);#t=new Float64Array(3);#s(t=this.#t[0],s=this.#t[1],i=this.#t[2]){if(t!==this.#n[0]||s!==this.#n[1]||i!==this.#n[2])this.#i=o(t**2+s**2+i**2),this.#n[0]=t,this.#n[1]=s,this.#n[2]=i}constructor(t=0,s=0,i=0){this.#t[0]=t,this.#t[1]=s,this.#t[2]=i,this.#s(t,s,i)}static add(t,s){return new l(t.#t[0]+s.#t[0],t.#t[1]+s.#t[1],t.#t[2]+s.#t[2])}static angleBetween(t,s){return m((t.#t[0]*s.#t[0]+t.#t[1]*s.#t[1]+t.#t[2]*s.#t[2])/(t.#i*s.#i))}static cross(t,s){const i=t.#t[0],n=t.#t[1],h=t.#t[2],e=s.#t[0],r=s.#t[1],u=s.#t[2];return new l(n*u-h*r,h*e-i*u,i*r-n*e)}static distance(t,s){return o((t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2+(t.#t[2]-s.#t[2])**2)}static distanceChebyshev(t,s){const i=a(t.#t[0]-s.#t[0]),n=a(t.#t[1]-s.#t[1]),h=a(t.#t[2]-s.#t[2]);return i>=n&&i>=h?i:n>=h?n:h}static distanceManhattan(t,s){return a(t.#t[0]-s.#t[0])+a(t.#t[1]-s.#t[1])+a(t.#t[2]-s.#t[2])}static distanceMinkowski(t,s,i){return(a(t.#t[0]-s.#t[0])**i+a(t.#t[1]-s.#t[1])**i+a(t.#t[2]-s.#t[2])**i)**(1/i)}static distanceSq(t,s){return(t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2+(t.#t[2]-s.#t[2])**2}static dot(t,s){return t.#t[0]*s.#t[0]+t.#t[1]*s.#t[1]+t.#t[2]*s.#t[2]}static fromCylindricalCoords(t,s,i){return new l(t*g(s),t*y(s),i)}static fromSphericalCoords(t,s,i){return new l(t*y(s)*g(i),t*y(s)*y(i),t*g(s))}static immutable(t=0,s=0,i=0){const n=new Float64Array(10);n[0]=t,n[1]=s,n[2]=i;const h=t**2+s**2;n[4]=c(o(s**2+i**2),t),n[5]=c(o(i**2+t**2),s),n[6]=c(o(h),i);const e=h+i**2;n[8]=o(e),n[9]=e;const r=t===1/0||t===-1/0||s===1/0||s===-1/0||i===1/0||i===-1/0,u=isNaN(t)&&isNaN(s)&&isNaN(i),I=t===0&&s===0&&i===0,Z=Object.freeze([...n.slice(0,3)]);return{get angleX(){return n[4]},get angleY(){return n[5]},get angleZ(){return n[6]},get b(){return n[2]},get g(){return n[1]},get isInfinite(){return r},get isNaN(){return u},get isZero(){return I},get magnitude(){return n[8]},get magnitudeSq(){return n[10]},get r(){return n[0]},get rgb(){return Z},get x(){return n[0]},get xyz(){return Z},get y(){return n[1]},get z(){return n[2]}}}static isInfinite(t){const s=t.#t[0],i=t.#t[1],n=t.#t[2];return s===1/0||s===-1/0||i===1/0||i===-1/0||n===1/0||n===-1/0}static isNaN(t){return isNaN(t.#t[0])||isNaN(t.#t[1])||isNaN(t.#t[2])}static isZero(t){return t.#t[0]===0&&t.#t[1]===0&&t.#t[2]===0}static lerp(t,s,i){if(i>1)i=1;else if(i<0)i=0;const n=t.#t[0],h=t.#t[1],e=t.#t[2];return new l(n+(s.#t[0]-n)*i,h+(s.#t[1]-h)*i,e+(s.#t[2]-e)*i)}static negate(t){return new l(-t.#t[0],-t.#t[1],-t.#t[2])}static normalize(t){const s=t.#i;return new l(t.#t[0]/s,t.#t[1]/s,t.#t[2]/s)}static project(t,s){const i=t.#i,n=s.#i,h=s.#t[0],e=s.#t[1],r=s.#t[2],u=i*g(m((t.#t[0]*h+t.#t[1]*e+t.#t[2]*r)/(i*n)));return new l(h/n*u,e/n*u,r/n*u)}static random(){let t,s;do t=f()*2-1,s=f()*2-1;while(t**2+s**2>=1);const i=o(1-t**2-s**2);return new l(2*t*i,2*s*i,1-2*(t**2+s**2))}static satisfyEquality(t,s){return t.#t[0]===s.#t[0]&&t.#t[1]===s.#t[1]&&t.#t[2]===s.#t[2]}static satisfyOpposition(t,s){return t.#t[0]===-s.#t[0]&&t.#t[1]===-s.#t[1]&&t.#t[2]===-s.#t[2]}static scale(t,s){return new l(t.#t[0]*s,t.#t[1]*s,t.#t[2]*s)}static subtract(t,s){return new l(t.#t[0]-s.#t[0],t.#t[1]-s.#t[1],t.#t[2]-s.#t[2])}static zero(){return new l}get angleX(){return c(o(this.#t[1]**2+this.#t[2]**2),this.#t[0])}get angleY(){return c(o(this.#t[2]**2+this.#t[0]**2),this.#t[1])}get angleZ(){return c(o(this.#t[0]**2+this.#t[1]**2),this.#t[2])}get b(){return this.#t[2]}get g(){return this.#t[1]}get magnitude(){return this.#i}get magnitudeSq(){return this.#i**2}get r(){return this.#t[0]}get rgb(){return[...this.#t]}get x(){return this.#t[0]}get xyz(){return[...this.#t]}get y(){return this.#t[1]}get z(){return this.#t[2]}set b(t){this.#t[2]=t,this.#s()}set g(t){this.#t[1]=t,this.#s()}set magnitude(t){const s=this.#i;this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#s()}set r(t){this.#t[0]=t,this.#s()}set rgb(t){this.#t[0]=t[0],this.#t[1]=t[1],this.#t[2]=t[2],this.#s()}set x(t){this.#t[0]=t,this.#s()}set xyz(t){this.#t[0]=t[0],this.#t[1]=t[1],this.#t[2]=t[2],this.#s()}set y(t){this.#t[1]=t,this.#s()}set z(t){this.#t[2]=t,this.#s()}add(t){return this.#t[0]+=t.#t[0],this.#t[1]+=t.#t[1],this.#t[2]+=t.#t[2],this.#s(),this}angleBetween(t){return m((this.#t[0]*t.#t[0]+this.#t[1]*t.#t[1]+this.#t[2]*t.#t[2])/(this.#i*t.#i))}clamp(t,s){const i=this.#i;if(i>s)this.#t[0]=this.#t[0]/i*s,this.#t[1]=this.#t[1]/i*s,this.#t[2]=this.#t[2]/i*s,this.#s();else if(i<t)this.#t[0]=this.#t[0]/i*t,this.#t[1]=this.#t[1]/i*t,this.#t[2]=this.#t[2]/i*t,this.#s();return this}clone(){return new l(this.#t[0],this.#t[1],this.#t[2])}copy(t){return this.#t[0]=t.#t[0],this.#t[1]=t.#t[1],this.#t[2]=t.#t[2],this.#s(),this}cross(t){const s=this.#t[0],i=this.#t[1],n=this.#t[2],h=t.#t[0],e=t.#t[1],r=t.#t[2];return this.#t[0]=i*r-n*e,this.#t[1]=n*h-s*r,this.#t[2]=s*e-i*h,this.#s(),this}distance(t){return o((this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2+(this.#t[2]-t.#t[2])**2)}distanceSq(t){return(this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2+(this.#t[2]-t.#t[2])**2}dot(t){return this.#t[0]*t.#t[0]+this.#t[1]*t.#t[1]+this.#t[2]*t.#t[2]}isInfinite(){const t=this.#t[0],s=this.#t[1],i=this.#t[2];return t===1/0||t===-1/0||s===1/0||s===-1/0||i===1/0||i===-1/0}isNaN(){return isNaN(this.#t[0])||isNaN(this.#t[1])||isNaN(this.#t[2])}isZero(){return this.#t[0]===0&&this.#t[1]===0&&this.#t[2]===0}limitMax(t){const s=this.#i;if(s>t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#s();return this}limitMin(t){const s=this.#i;if(s<t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#s();return this}lookAt(t){const s=this.#i,i=t.#i;return this.#t[0]=t.#t[0]/i*s,this.#t[1]=t.#t[1]/i*s,this.#t[2]=t.#t[2]/i*s,this.#s(),this}negate(){return this.#t[0]*=-1,this.#t[1]*=-1,this.#t[2]*=-1,this.#s(),this}normalize(){const t=this.#i;return this.#t[0]/=t,this.#t[1]/=t,this.#t[2]/=t,this.#s(),this}project(t){const s=this.#i,i=t.#i,n=t.#t[0],h=t.#t[1],e=t.#t[2],r=s*g(m((this.#t[0]*n+this.#t[1]*h+this.#t[2]*e)/(s*i)));return this.#t[0]=n/i*r,this.#t[1]=h/i*r,this.#t[2]=e/i*r,this.#s(),this}random(){let t,s;do t=f()*2-1,s=f()*2-1;while(t**2+s**2>=1);const i=o(1-t**2-s**2),n=this.#i;return this.#t[0]=n*2*t*i,this.#t[1]=n*2*s*i,this.#t[2]=n*(1-2*(t**2+s**2)),this.#s(),this}rotateX(t){const s=g(t),i=y(t),n=this.#t[1],h=this.#t[2];return this.#t[1]=n*s-h*i,this.#t[2]=n*i+h*s,this.#s(),this}rotateY(t){const s=g(t),i=y(t),n=this.#t[0],h=this.#t[2];return this.#t[0]=n*s+h*i,this.#t[2]=n*i+h*s,this.#s(),this}rotateZ(t){const s=g(t),i=y(t),n=this.#t[0],h=this.#t[1];return this.#t[0]=n*s-h*i,this.#t[1]=n*i+h*s,this.#s(),this}satisfyEquality(t){return this.#t[0]===t.#t[0]&&this.#t[1]===t.#t[1]&&this.#t[2]===t.#t[2]}satisfyOpposition(t){return this.#t[0]===-t.#t[0]&&this.#t[1]===-t.#t[1]&&this.#t[2]===-t.#t[2]}scale(t){return this.#t[0]*=t,this.#t[1]*=t,this.#t[2]*=t,this.#s(),this}subtract(t){return this.#t[0]-=t.#t[0],this.#t[1]-=t.#t[1],this.#t[2]-=t.#t[2],this.#s(),this}zero(){return this.#t[0]=0,this.#t[1]=0,this.#t[2]=0,this.#s(),this}*[Symbol.iterator](){yield this.#t[0],yield this.#t[1],yield this.#t[2]}}class N{#i=0;#n=new Float64Array([0,0,0,0]);#t=new Float64Array(4);#s(t=this.#t[0],s=this.#t[1],i=this.#t[2],n=this.#t[3]){if(t!==this.#n[0]||s!==this.#n[1]||i!==this.#n[2]||n!==this.#n[3])this.#i=o(t**2+s**2+i**2+n**2),this.#n[0]=t,this.#n[1]=s,this.#n[2]=i,this.#n[3]=n}constructor(t=0,s=0,i=0,n=0){this.#t[0]=t,this.#t[1]=s,this.#t[2]=i,this.#t[3]=n,this.#s(t,s,i,n)}static add(t,s){return new N(t.#t[0]+s.#t[0],t.#t[1]+s.#t[1],t.#t[2]+s.#t[2],t.#t[3]+s.#t[3])}static angleBetween(t,s){return m((t.#t[0]*s.#t[0]+t.#t[1]*s.#t[1]+t.#t[2]*s.#t[2]+t.#t[3]*s.#t[3])/(t.#i*s.#i))}static distance(t,s){return o((t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2+(t.#t[2]-s.#t[2])**2+(t.#t[3]-s.#t[3])**2)}static distanceChebyshev(t,s){const i=a(t.#t[0]-s.#t[0]),n=a(t.#t[1]-s.#t[1]),h=a(t.#t[2]-s.#t[2]),e=a(t.#t[3]-s.#t[3]);return i>=n&&i>=h&&i>=e?i:n>=h&&n>=e?n:h>=e?h:e}static distanceManhattan(t,s){return a(t.#t[0]-s.#t[0])+a(t.#t[1]-s.#t[1])+a(t.#t[2]-s.#t[2])+a(t.#t[3]-s.#t[3])}static distanceMinkowski(t,s,i){return(a(t.#t[0]-s.#t[0])**i+a(t.#t[1]-s.#t[1])**i+a(t.#t[2]-s.#t[2])**i+a(t.#t[3]-s.#t[3])**i)**(1/i)}static distanceSq(t,s){return(t.#t[0]-s.#t[0])**2+(t.#t[1]-s.#t[1])**2+(t.#t[2]-s.#t[2])**2+(t.#t[3]-s.#t[3])**2}static dot(t,s){return t.#t[0]*s.#t[0]+t.#t[1]*s.#t[1]+t.#t[2]*s.#t[2]+t.#t[3]*s.#t[3]}static immutable(t=0,s=0,i=0,n=0){const h=new Float64Array(10);h[0]=t,h[1]=s,h[2]=i,h[3]=n;const e=t**2+s**2+i**2;h[4]=c(o(s**2+i**2+n**2),t),h[5]=c(o(i**2+n**2+t**2),s),h[6]=c(o(n**2+t**2+s**2),i),h[7]=c(o(e),n);const r=e+n**2;h[8]=o(r),h[9]=r;const u=t===1/0||t===-1/0||s===1/0||s===-1/0||i===1/0||i===-1/0||n===1/0||n===-1/0,I=isNaN(t)&&isNaN(s)&&isNaN(i)&&isNaN(n),Z=t===0&&s===0&&i===0&&n===0,M=Object.freeze([...h.slice(0,4)]);return{get a(){return h[3]},get angleW(){return h[7]},get angleX(){return h[4]},get angleY(){return h[5]},get angleZ(){return h[6]},get b(){return h[2]},get g(){return h[1]},get isInfinite(){return u},get isNaN(){return I},get isZero(){return Z},get magnitude(){return h[8]},get magnitudeSq(){return h[10]},get r(){return h[0]},get rgba(){return M},get w(){return h[3]},get x(){return h[0]},get xyzw(){return M},get y(){return h[1]},get z(){return h[2]}}}static isInfinite(t){const s=t.#t[0],i=t.#t[1],n=t.#t[2],h=t.#t[3];return s===1/0||s===-1/0||i===1/0||i===-1/0||n===1/0||n===-1/0||h===1/0||h===-1/0}static isNaN(t){return isNaN(t.#t[0])||isNaN(t.#t[1])||isNaN(t.#t[2])||isNaN(t.#t[3])}static isZero(t){return t.#t[0]===0&&t.#t[1]===0&&t.#t[2]===0&&t.#t[3]===0}static lerp(t,s,i){if(i>1)i=1;else if(i<0)i=0;const n=t.#t[0],h=t.#t[1],e=t.#t[2],r=t.#t[3];return new N(n+(s.#t[0]-n)*i,h+(s.#t[1]-h)*i,e+(s.#t[2]-e)*i,r+(s.#t[3]-r)*i)}static negate(t){return new N(-t.#t[0],-t.#t[1],-t.#t[2],-t.#t[3])}static normalize(t){const s=t.#i;return new N(t.#t[0]/s,t.#t[1]/s,t.#t[2]/s,t.#t[3]/s)}static project(t,s){const i=t.#i,n=s.#i,h=s.#t[0],e=s.#t[1],r=s.#t[2],u=s.#t[3],I=i*g(m((t.#t[0]*h+t.#t[1]*e+t.#t[2]*r+t.#t[3]*u)/(i*n)));return new N(h/n*I,e/n*I,r/n*I,u/n*I)}static random(){let t,s,i,n;do t=f()*2-1,s=f()*2-1,i=f()*2-1,n=f()*2-1;while(t**2+s**2>=1||i**2+n**2>=1);const h=o((1-t**2-s**2)/(i**2+n**2));return new N(t,s,i*h,n*h)}static satisfyEquality(t,s){return t.#t[0]===s.#t[0]&&t.#t[1]===s.#t[1]&&t.#t[2]===s.#t[2]&&t.#t[3]===s.#t[3]}static satisfyOpposition(t,s){return t.#t[0]===-s.#t[0]&&t.#t[1]===-s.#t[1]&&t.#t[2]===-s.#t[2]&&t.#t[3]===-s.#t[3]}static scale(t,s){return new N(t.#t[0]*s,t.#t[1]*s,t.#t[2]*s,t.#t[3]*s)}static subtract(t,s){return new N(t.#t[0]-s.#t[0],t.#t[1]-s.#t[1],t.#t[2]-s.#t[2],t.#t[3]-s.#t[3])}static zero(){return new N}get a(){return this.#t[3]}get angleW(){return c(o(this.#t[0]**2+this.#t[1]**2+this.#t[2]**2),this.#t[3])}get angleX(){return c(o(this.#t[1]**2+this.#t[2]**2+this.#t[3]**2),this.#t[0])}get angleY(){return c(o(this.#t[2]**2+this.#t[3]**2+this.#t[0]**2),this.#t[1])}get angleZ(){return c(o(this.#t[3]**2+this.#t[0]**2+this.#t[1]**2),this.#t[2])}get b(){return this.#t[2]}get g(){return this.#t[1]}get magnitude(){return this.#i}get magnitudeSq(){return this.#i**2}get r(){return this.#t[0]}get rgba(){return[...this.#t]}get w(){return this.#t[3]}get x(){return this.#t[0]}get xyzw(){return[...this.#t]}get y(){return this.#t[1]}get z(){return this.#t[2]}set a(t){this.#t[3]=t,this.#s()}set b(t){this.#t[2]=t,this.#s()}set g(t){this.#t[1]=t,this.#s()}set magnitude(t){const s=this.#i;this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#t[3]=this.#t[3]/s*t,this.#s()}set r(t){this.#t[0]=t,this.#s()}set rgba(t){this.#t[0]=t[0],this.#t[1]=t[1],this.#t[2]=t[2],this.#t[3]=t[3],this.#s()}set w(t){this.#t[3]=t,this.#s()}set x(t){this.#t[0]=t,this.#s()}set xyzw(t){this.#t[0]=t[0],this.#t[1]=t[1],this.#t[2]=t[2],this.#t[3]=t[3],this.#s()}set y(t){this.#t[1]=t,this.#s()}set z(t){this.#t[2]=t,this.#s()}add(t){return this.#t[0]+=t.#t[0],this.#t[1]+=t.#t[1],this.#t[2]+=t.#t[2],this.#t[3]+=t.#t[3],this.#s(),this}angleBetween(t){return m((this.#t[0]*t.#t[0]+this.#t[1]*t.#t[1]+this.#t[2]*t.#t[2]+this.#t[3]*t.#t[3])/(this.#i*t.#i))}clamp(t,s){const i=this.#i;if(i>s)this.#t[0]=this.#t[0]/i*s,this.#t[1]=this.#t[1]/i*s,this.#t[2]=this.#t[2]/i*s,this.#t[3]=this.#t[3]/i*s,this.#s();else if(i<t)this.#t[0]=this.#t[0]/i*t,this.#t[1]=this.#t[1]/i*t,this.#t[2]=this.#t[2]/i*t,this.#t[3]=this.#t[3]/i*t,this.#s();return this}clone(){return new N(this.#t[0],this.#t[1],this.#t[2],this.#t[3])}copy(t){return this.#t[0]=t.#t[0],this.#t[1]=t.#t[1],this.#t[2]=t.#t[2],this.#t[3]=t.#t[3],this.#s(),this}distance(t){return o((this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2+(this.#t[2]-t.#t[2])**2+(this.#t[3]-t.#t[3])**2)}distanceSq(t){return(this.#t[0]-t.#t[0])**2+(this.#t[1]-t.#t[1])**2+(this.#t[2]-t.#t[2])**2+(this.#t[3]-t.#t[3])**2}dot(t){return this.#t[0]*t.#t[0]+this.#t[1]*t.#t[1]+this.#t[2]*t.#t[2]+this.#t[3]*t.#t[3]}isInfinite(){const t=this.#t[0],s=this.#t[1],i=this.#t[2],n=this.#t[3];return t===1/0||t===-1/0||s===1/0||s===-1/0||i===1/0||i===-1/0||n===1/0||n===-1/0}isNaN(){return isNaN(this.#t[0])||isNaN(this.#t[1])||isNaN(this.#t[2])||isNaN(this.#t[3])}isZero(){return this.#t[0]===0&&this.#t[1]===0&&this.#t[2]===0&&this.#t[3]===0}limitMax(t){const s=this.#i;if(s>t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#t[3]=this.#t[3]/s*t,this.#s();return this}limitMin(t){const s=this.#i;if(s<t)this.#t[0]=this.#t[0]/s*t,this.#t[1]=this.#t[1]/s*t,this.#t[2]=this.#t[2]/s*t,this.#t[3]=this.#t[3]/s*t,this.#s();return this}lookAt(t){const s=this.#i,i=t.#i;return this.#t[0]=t.#t[0]/i*s,this.#t[1]=t.#t[1]/i*s,this.#t[2]=t.#t[2]/i*s,this.#t[3]=t.#t[3]/i*s,this.#s(),this}negate(){return this.#t[0]*=-1,this.#t[1]*=-1,this.#t[2]*=-1,this.#t[3]*=-1,this.#s(),this}normalize(){const t=this.#i;return this.#t[0]/=t,this.#t[1]/=t,this.#t[2]/=t,this.#t[3]/=t,this.#s(),this}project(t){const s=this.#i,i=t.#i,n=t.#t[0],h=t.#t[1],e=t.#t[2],r=t.#t[3],u=s*g(m((this.#t[0]*n+this.#t[1]*h+this.#t[2]*e+this.#t[3]*r)/(s*i)));return this.#t[0]=n/i*u,this.#t[1]=h/i*u,this.#t[2]=e/i*u,this.#t[3]=r/i*u,this.#s(),this}random(){let t,s,i,n;do t=f()*2-1,s=f()*2-1,i=f()*2-1,n=f()*2-1;while(t**2+s**2>=1||i**2+n**2>=1);const h=o((1-t**2-s**2)/(i**2+n**2)),e=this.#i;return this.#t[0]=e*t,this.#t[1]=e*s,this.#t[2]=e*i*h,this.#t[3]=e*n*h,this.#s(),this}satisfyEquality(t){return this.#t[0]===t.#t[0]&&this.#t[1]===t.#t[1]&&this.#t[2]===t.#t[2]&&this.#t[3]===t.#t[3]}satisfyOpposition(t){return this.#t[0]===-t.#t[0]&&this.#t[1]===-t.#t[1]&&this.#t[2]===-t.#t[2]&&this.#t[3]===-t.#t[3]}scale(t){return this.#t[0]*=t,this.#t[1]*=t,this.#t[2]*=t,this.#t[3]*=t,this.#s(),this}subtract(t){return this.#t[0]-=t.#t[0],this.#t[1]-=t.#t[1],this.#t[2]-=t.#t[2],this.#t[3]-=t.#t[3],this.#s(),this}zero(){return this.#t[0]=0,this.#t[1]=0,this.#t[2]=0,this.#t[3]=0,this.#s(),this}*[Symbol.iterator](){yield this.#t[0],yield this.#t[1],yield this.#t[2],yield this.#t[3]}}export{N as Vec4,l as Vec3,d as Vec2};
